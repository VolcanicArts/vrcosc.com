"use strict";(self.webpackChunkvrcosc_com=self.webpackChunkvrcosc_com||[]).push([["3173"],{773:function(e,a,r){r.r(a),r.d(a,{default:()=>c,frontMatter:()=>i,metadata:()=>t,assets:()=>d,toc:()=>l,contentTitle:()=>o});var t=JSON.parse('{"id":"v2/sdk/parameters","title":"Parameters","description":"Create and use module parameters","source":"@site/docs/v2/sdk/parameters.md","sourceDirName":"v2/sdk","slug":"/v2/sdk/parameters","permalink":"/docs/v2/sdk/parameters","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"description":"Create and use module parameters"},"sidebar":"docsSidebar","previous":{"title":"Settings","permalink":"/docs/v2/sdk/settings"},"next":{"title":"ChatBox","permalink":"/docs/v2/sdk/chatbox"}}'),n=r("5893"),s=r("65");let i={sidebar_position:5,description:"Create and use module parameters"},o="Parameters",d={},l=[{value:"Registering Parameters",id:"registering-parameters",level:2},{value:"Sending Parameters",id:"sending-parameters",level:2},{value:"Receiving Parameters",id:"receiving-parameters",level:2},{value:"Wildcards",id:"wildcards",level:2},{value:"Waiting",id:"waiting",level:2},{value:"OSCQuery",id:"oscquery",level:2},{value:"VRCFury",id:"vrcfury",level:2}];function h(e){let a={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(a.header,{children:(0,n.jsx)(a.h1,{id:"parameters",children:"Parameters"})}),"\n",(0,n.jsx)(a.p,{children:"Parameters are the main way VRCOSC and VRChat communicate. For all intents and purposes, the parameters you register and use in a module are the avatar parameters on your avatar."}),"\n",(0,n.jsx)(a.h2,{id:"registering-parameters",children:"Registering Parameters"}),"\n",(0,n.jsx)(a.p,{children:"Registered parameters are parameters that have a defined lookup (usually denoted by an Enum), so that the user can change the name of the parameter and your module still works fine as the lookup is controlled by you. Any parameter that your module is going to be using on each run should be registered, as this allows the user to customise their setup."}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-csharp",children:'RegisterParameter<bool>(MediaParameter.Play, "VRCOSC/Media/Play", ParameterMode.ReadWrite, "Play/Pause", "True for playing. False for paused");\r\nRegisterParameter<float>(MediaParameter.Volume, "VRCOSC/Media/Volume", ParameterMode.ReadWrite, "Volume", "The volume of the process that is controlling the media");\r\nRegisterParameter<int>(MediaParameter.Repeat, "VRCOSC/Media/Repeat", ParameterMode.ReadWrite, "Repeat", "0 - Disabled\\n1 - Single\\n2 - List");\n'})}),"\n",(0,n.jsx)(a.p,{children:"Let's go over each of the parts of the method."}),"\n",(0,n.jsxs)(a.p,{children:["First, I'm calling ",(0,n.jsx)(a.code,{children:"RegisterParameter<T>"}),", where T is the type of parameter I want. This accepts ",(0,n.jsx)(a.code,{children:"int"}),", ",(0,n.jsx)(a.code,{children:"float"}),", and ",(0,n.jsx)(a.code,{children:"bool"}),"."]}),"\n",(0,n.jsxs)(a.p,{children:["For the first argument, I have an Enum named ",(0,n.jsx)(a.code,{children:"MediaParameter"}),". This contains all the lookups for each of the parameters. As mentioned before, this is a nicer way of organising parameters so you don't have to worry about spelling the lookup correctly."]}),"\n",(0,n.jsx)(a.p,{children:"Next is the name of the parameter. This name is the exact name it would be on the avatar."}),"\n",(0,n.jsx)(a.p,{children:"After that is the parameter mode. This is just used for safety to tell VRCOSC if a parameter can read from VRChat, write to VRChat, or both."}),"\n",(0,n.jsx)(a.p,{children:"Finally, the rest of the method call is metadata, which is the display name and display description of the parameter."}),"\n",(0,n.jsx)(a.p,{children:"There is also an optional bool at the end to mark a parameter as legacy, meaning it's still available to use but might be removed in the future, so this lets users know to change over to newer parameters else their prefabs might break."}),"\n",(0,n.jsx)(a.admonition,{type:"info",children:(0,n.jsxs)(a.p,{children:["VRChat sends out parameters using the ",(0,n.jsx)(a.code,{children:"/avatar/parameters/"})," prefix but VRCOSC handles this for you."]})}),"\n",(0,n.jsx)(a.h2,{id:"sending-parameters",children:"Sending Parameters"}),"\n",(0,n.jsx)(a.p,{children:"To send a parameter, there are 2 methods you can use:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-csharp",children:"SendParameter(MediaParameter.Play, true);\r\nSendParameter(MediaParameter.Shuffle, false);\r\nSendParameter(MediaParameter.Repeat, 0);\n"})}),"\n",(0,n.jsxs)(a.p,{children:["This uses the ",(0,n.jsx)(a.code,{children:"MediaParameter"})," Enum to send to a registered parameter. Behind the scenes, VRCOSC is taking the parameter name that the user has set this registered parameter to and sending the data there, which abstracts your module from having to deal with different parameter names."]}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-csharp",children:'SendParameter("MyNormalParameter", false);\n'})}),"\n",(0,n.jsx)(a.p,{children:"For the above, you can send directly to a parameter using its name. This is not customisable by the user and should be used sparingly when you want to send to a parameter you know will never change name."}),"\n",(0,n.jsx)(a.h2,{id:"receiving-parameters",children:"Receiving Parameters"}),"\n",(0,n.jsx)(a.p,{children:"To receive a parameter, there are 2 methods to override:"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-csharp",children:"protected override void OnRegisteredParameterReceived(RegisteredParameter parameter)\r\n{\r\n    switch (parameter.Lookup)\r\n    {\r\n        case MediaParameter.Volume:\r\n            MediaProvider.TryChangeVolume(parameter.GetValue<float>());\r\n            break;\r\n    }\r\n}\n"})}),"\n",(0,n.jsxs)(a.p,{children:["This listens for registered parameters. Registered parameters, once again, have the benefit of being abstracted from your module, so you can listen for whenever the lookup arrives and the user can change the parameter name to whatever they need it to be. Registered parameters can give you access to the parameter value using ",(0,n.jsx)(a.code,{children:"GetValue<T>()"}),", where T is the type of the parameter's value. Note: This type must match the type that it's expecting else an error will be thrown."]}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-csharp",children:'protected override void OnAnyParameterReceived(ReceivedParameter parameter)\r\n{\r\n    switch (parameter.Name)\r\n    {\r\n        case "MyNormalParameter":\r\n            Log($"MyNormalParameter\'s value is {parameter.GetValue<bool>()}")\r\n            break;\r\n    }\r\n}\n'})}),"\n",(0,n.jsxs)(a.p,{children:["You can also listen for any parameter. Unregistered ",(0,n.jsx)(a.em,{children:"and"})," registered parameters will call this method, and registered parameters will call this before calling ",(0,n.jsx)(a.code,{children:"OnRegisteredParameterReceived"}),", so only use if it you need to. An example of a good use of this is the Counter module, as it listens for any parameter that arrives and if it finds a match for a parameter that a counter needs it can then use the parameter's data to increase the counter's value."]}),"\n",(0,n.jsx)(a.h2,{id:"wildcards",children:"Wildcards"}),"\n",(0,n.jsxs)(a.p,{children:["Wildcards are available to registered parameters. When you put a ",(0,n.jsx)(a.code,{children:"*"})," in a parameter, for example, ",(0,n.jsx)(a.code,{children:"MyParameter/*"}),", the ",(0,n.jsx)(a.code,{children:"*"})," can be changed to anything on the user's avatar.\r\nIn your module, ",(0,n.jsx)(a.code,{children:"OnRegisteredParameterReceived"})," will be triggered for any parameter that matches ",(0,n.jsx)(a.code,{children:"MyParameter/*"}),". You can have as many wildcards as you want in your parameter."]}),"\n",(0,n.jsxs)(a.p,{children:["To check if the wildcard exists, you can call ",(0,n.jsx)(a.code,{children:"parameter.IsWildcardType<T>(position)"}),", where ",(0,n.jsx)(a.code,{children:"T"})," is checking if the wildcard can be changed into that type, and ",(0,n.jsx)(a.code,{children:"position"})," is the position of the wildcard."]}),"\n",(0,n.jsxs)(a.p,{children:["To extract the wildcard, you can call ",(0,n.jsx)(a.code,{children:"parameter.GetWildcard<T>(position)"}),"."]}),"\n",(0,n.jsx)(a.admonition,{type:"info",children:(0,n.jsx)(a.p,{children:"To keep consistency, wildcards only support the string, int, and float types."})}),"\n",(0,n.jsx)(a.h2,{id:"waiting",children:"Waiting"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-csharp",children:"SendParameterAndWait(MyParameters.SomeParameter, true, true)\n"})}),"\n",(0,n.jsxs)(a.p,{children:[(0,n.jsx)(a.code,{children:"SendParameterAndWait"})," allows you to send a parameter, and if that parameter is present on the user's avatar, wait for the response. This is useful for when you're wanting to use the same parameter for multiple bits of data, but want to make sure that the avatar has handled the data before sending the parameter again."]}),"\n",(0,n.jsxs)(a.p,{children:["Setting the third field to true, which is the block events field, will block ",(0,n.jsx)(a.code,{children:"OnRegisteredParameterReceived"})," from being called with that parameter until a response has been sent from VRChat.\r\nThis is useful for when you don't want loopbacks in your parameters."]}),"\n",(0,n.jsxs)(a.p,{children:["A good example of how this is used is in the ",(0,n.jsx)(a.a,{href:"https://github.com/VolcanicArts/VRCOSC-Modules/blob/main/VRCOSC.Modules/Media/MediaModule.cs#L178",children:"Media"})," module.\r\nWe don't want the initial setting of the parameters going out to loopback into the module and change the state of Windows media, so we ignore the loopback update from VRChat when sending those parameters out."]}),"\n",(0,n.jsx)(a.h2,{id:"oscquery",children:"OSCQuery"}),"\n",(0,n.jsx)(a.p,{children:"OSCQuery lets you retrieve parameter types and values, allowing you to check types and values without the parameter ever having to change in-game."}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-csharp",children:'FindParameter(MyParameters.SomeParameter);\r\nFindParameter("SomeParameterName");\n'})}),"\n",(0,n.jsx)(a.p,{children:"If the parameter doesn't exist or OSCQuery isn't working for VRChat, null will be returned."}),"\n",(0,n.jsx)(a.h2,{id:"vrcfury",children:"VRCFury"}),"\n",(0,n.jsx)(a.admonition,{type:"warning",children:(0,n.jsxs)(a.p,{children:["This feature is a fail-safe and for advanced users. It's still recommended to set the parameters that VRCOSC is using to global. You can mark the parameters as global in a Full Controller by adding a ",(0,n.jsx)(a.code,{children:"*"})," in the first instance of a global parameters list in the advanced settings of the Full Controller."]})}),"\n",(0,n.jsxs)(a.p,{children:["VRCOSC will automatically handle VRCFury prefixes for registered parameters. If VRCOSC detects ",(0,n.jsx)(a.code,{children:"VF65_MyParameter"})," it will treat it as if ",(0,n.jsx)(a.code,{children:"MyParameter"})," has arrived. This is important to understand as if there are multiple ",(0,n.jsx)(a.code,{children:"MyParameter"}),"s it will trigger the same registered parameter. Sometimes this can be useful for prefabs that control modules like Media."]})]})}function c(e={}){let{wrapper:a}={...(0,s.a)(),...e.components};return a?(0,n.jsx)(a,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},65:function(e,a,r){r.d(a,{Z:function(){return o},a:function(){return i}});var t=r(7294);let n={},s=t.createContext(n);function i(e){let a=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function o(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),t.createElement(s.Provider,{value:a},e.children)}}}]);