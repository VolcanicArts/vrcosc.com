"use strict";(self.webpackChunkvrcosc_com=self.webpackChunkvrcosc_com||[]).push([["5532"],{1263:function(e,n,s){s.r(n),s.d(n,{default:()=>h,frontMatter:()=>i,metadata:()=>t,assets:()=>a,toc:()=>o,contentTitle:()=>l});var t=JSON.parse('{"id":"v2/sdk/handlers","title":"Handlers","description":"Interface with global events","source":"@site/docs/v2/sdk/handlers.md","sourceDirName":"v2/sdk","slug":"/v2/sdk/handlers","permalink":"/docs/v2/sdk/handlers","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"description":"Interface with global events"},"sidebar":"docsSidebar","previous":{"title":"ChatBox","permalink":"/docs/v2/sdk/chatbox"},"next":{"title":"Persistence","permalink":"/docs/v2/sdk/persistence"}}'),r=s("5893"),c=s("65");let i={sidebar_position:6,description:"Interface with global events"},l="Handlers",a={},o=[{value:"Speech Handler",id:"speech-handler",level:2},{value:"Client Events Handler",id:"client-events-handler",level:2}];function d(e){let n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",...(0,c.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"handlers",children:"Handlers"})}),"\n",(0,r.jsx)(n.h2,{id:"speech-handler",children:"Speech Handler"}),"\n",(0,r.jsxs)(n.p,{children:["VRCOSC's speech engine is global, meaning you can implement ",(0,r.jsx)(n.code,{children:"ISpeechHandler"})," and speech recognition will be handled entirely by the app."]}),"\n",(0,r.jsxs)(n.p,{children:["2 methods are exposed, ",(0,r.jsx)(n.code,{children:"OnPartialSpeechResult"})," and ",(0,r.jsx)(n.code,{children:"OnFinalSpeechResult"}),". Both provide the text of what the user has said."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"OnPartialSpeechResult"})," occurs every 1.5 seconds while the user is still talking."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"OnFinalSpeechResult"})," occurs when the user has stopped talking and a final more accurate recognition is done."]}),"\n",(0,r.jsx)(n.h2,{id:"client-events-handler",children:"Client Events Handler"}),"\n",(0,r.jsxs)(n.p,{children:["VRCOSC scans VRChat's logs for certain events, meaning you can implement ",(0,r.jsx)(n.code,{children:"IVRCClientEventHandler"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"OnInstanceLeft"})," occurs when the user leaves their current instance."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"OnInstanceJoin"})," occurs when the user finishes joining the new instance."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"OnUserLeft"})," occurs when a remote user leaves the current instance."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"OnUserJoined"})," occurs when a remote user joins the current instance."]}),"\n",(0,r.jsxs)(n.p,{children:["All events are passed with their relevant data and the time at which the log occurred. The whole log file is scanned once on start to allow modules to backfill data if needed (see the instance user count of ",(0,r.jsx)(n.a,{href:"https://github.com/VolcanicArts/VRCOSC-Modules/blob/main/VRCOSC.Modules/ClientInfo/ClientInfoModule.cs#L62",children:"ClientInfo"}),"). Make sure to ignore any logs from the past if you only need new data."]})]})}function h(e={}){let{wrapper:n}={...(0,c.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},65:function(e,n,s){s.d(n,{Z:function(){return l},a:function(){return i}});var t=s(7294);let r={},c=t.createContext(r);function i(e){let n=t.useContext(c);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(c.Provider,{value:n},e.children)}}}]);